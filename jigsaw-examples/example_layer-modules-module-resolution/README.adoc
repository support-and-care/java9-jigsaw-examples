:icons: font
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
== Example example_layer-modules-before-finder

Part of the full xref:../../README.adoc[Java 9 Jigsaw modules example] suite.

[IMPORTANT]
.Authors
====
Originally written by https://github.com/mrtnlhmnn[Martin Lehmann], https://github.com/kristines[Kristine Schaal] and https://github.com/rgrammes[RÃ¼diger Grammes] (cf. https://github.com/accso/java9-jigsaw-examples[original repository]).

Migrated for JPMS support documentation of Apache Maven^TM^ in the course of the https://open-elements.com/support-care-maven/[Maven Support & Care] program by https://github.com/ascheman[Gerd Aschemann] (and other team members) as https://github.com/support-and-care/java9-jigsaw-examples[forked repository].
Please add discussions, requirements, bugfixes, etc. to the fork instead of the original.
====

== What is this example about?

This example is similar to xref:../example_layer-modules-grouped-in-hierarchy/README.adoc[this example].
It shows how a module from the boot layer can be overwritten in a child layer depending on the order of resolution.

=== Layers in this example

We have the boot layer as the parent layer for these three child layers:

* `foo layer #1` which contains the module `modfoo` which requires the modules `modversion1` and `modcommon`
* `bar layer #1` which contains the module `modbar` which requires the modules `modversion2` and `modcommon`
* `bar layer #2` which contains the module `modbar` which requires the modules `modversion2` and `modcommon`

The boot layer contains these modules (from mlib/)

* `modcommon` which has standard functionality used by all other modules
* `modmain` which does reflective calls to `modbar` and `modfoo`

The foo layer contains these modules (from foomlib/)

* `modversion1` which produces the version string "V1"
* `modfoo` which prints its id and the version from modversion1

The bar layers contains these modules (from barmlib/)

* `modcommon`, a new version of modcommon found in boot layer.
It prints certain texts in blue colour on ANSI terminals.
* `modversion2` which produces the version string "V2"
* `modbar` which prints its id and the version from modversion2

=== Example shows ...

This exampe shows how modcommon is resolved differently depending on how a layer is created:

* modmain resolves modcommon from the module path (mlib/), both end up in the boot layer on startup.
* modfoo is placed in the newly created foo-layer together with modversion1.
Its "module path" foomlib/ does not contain modcommon so it is resolved from the boot layer.
* modbar is placed in the newly created bar-layer #1 together with modversion2.
barmlib/ does contain a new version of modcommon, however, the boot layer version is found first and is thus used.
* modbar is again played in the newly created bar-layer #2 together with modversion2.
This time, we create the layer putting barmlib/ in the so-called "before"-ModuleFinder.
Now the new version of modcommon is resolved instead, and we see blue output on ANSI terminals when this version of modbar is called.

Note that using automatic modules in either bar-layer #1 or #2 will lead to failure.
An automatic module will try to add reads dependencies to all modules in the bar-layer and in the parent boot layer.
In doing this, it tries to read from both modcommon in boot as well as modcommon in bar!
This leads to a module resolution error.

=== Output

This example uses xref:../../README.adoc#golden-master-testing[golden master testing] to ensure output consistency.
The expected output is compared with actual output using `verify.sh`.

==== Expected Output

[source]
----
include::expected-result/run.txt[]
----

==== Actual Output

[source]
----
include::run-result/run.txt[]
----

==== Maven 4 Output

[source]
----
include::m4/run-result/run.txt[]
----

[[sec:maven-4-migration]]
== Maven 4 Migration

This example required a special migration approach due to its unique requirement of compiling multiple versions of the same module.

=== Standard Migration

The primary modules (modbar, modcommon v1.0, modfoo, modmain, modversion1, modversion2) were migrated using the standard Module Source Hierarchy approach documented in the xref:../../README.adoc#maven-4-migration[central Maven 4 Migration guide].

=== Special Handling: Multiple Module Versions

This example demonstrates module layer resolution by using two different versions of `modcommon`:

. `modcommon` v1.0 (from `src/modcommon`) - used in the boot layer
. `modcommon` v2.0 (from `src2/modcommon`) - used in bar layer #2 to demonstrate version overriding

Problem::
Maven 4's Module Source Hierarchy cannot handle multiple versions of the same module in a single build.
The `<sources>` element expects one source location per module name.

Solution::
Hybrid compilation approach in `m4/compile.sh`:
+
. Maven compiles the primary modules including modcommon v1.0 via the standard Module Source Hierarchy
. Manual javac invocation compiles modcommon v2.0 from src2/:
+
[source,bash]
----
javac -d mods2 --release 11 --module-version=2.0 \
      --module-path mlib --module-source-path ../src2 \
      $(find ../src2/modcommon -name "*.java")
----
+
. JAR placement follows the original structure:
** mlib/ - boot layer modules (modcommon v1.0, modmain)
** foomlib/ - foo layer modules (modfoo, modversion1)
** barmlib/ - bar layer modules (modbar, modversion2, modcommon v2.0)

This hybrid approach is necessary because:

* Maven 4's Module Source Hierarchy is designed for single-version module builds
* The example's educational value depends on demonstrating module version resolution in layers
* Manual compilation of the second version preserves the example's behavior while leveraging Maven 4 for the primary build
