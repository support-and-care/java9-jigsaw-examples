:icons: font
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
== Example example_unnamed-module_access-from-automatic-module

Part of the full xref:../../README.adoc[Java 9 Jigsaw modules example] suite.

[IMPORTANT]
.Authors
====
Originally written by https://github.com/mrtnlhmnn[Martin Lehmann], https://github.com/kristines[Kristine Schaal] and https://github.com/rgrammes[RÃ¼diger Grammes] (cf. https://github.com/accso/java9-jigsaw-examples[original repository]).

Migrated for JPMS support documentation of Apache Maven^TM^ in the course of the https://open-elements.com/support-care-maven/[Maven Support & Care] program by https://github.com/ascheman[Gerd Aschemann] (and other team members) as https://github.com/support-and-care/java9-jigsaw-examples[forked repository].
Please add discussions, requirements, bugfixes, etc. to the fork instead of the original.
====

== What is this example about?

This example is about the access to the unnamed module, i.e. to the classpath from an automatic module.

=== Modules in this example

* modmain.auto - an automatic module calling classes on the classpath.
* cpa - classes on the classpath

=== Example shows ...

The examples illustrates the accessibility rules access to the classpath (i.e. in the unnamed module) from automatic modules.
In this example, we show that classes from an automatic module (and only them!) can access all classes from the classpath (the unnamed module) both directly and via reflection.
This means that all packages from the unnamed module are implicitly exported and opened to automatic modules.

The script run.sh starts the main class from `modmain.auto`.

Note: No JavaDoc generation for this example.

=== Output

This example uses xref:../../README.adoc#golden-master-testing[golden master testing] to ensure output consistency.
The expected output is compared with actual output using `verify.sh`.

==== Expected Output

[source]
----
include::expected-result/run.txt[]
----

==== Actual Output

[source]
----
include::run-result/run.txt[]
----

==== Maven 4 Output

[source]
----
include::m4/run-result/run.txt[]
----

[[sec:maven-4-migration]]
== Maven 4 Migration

This example required a special migration approach as it contains NO explicit modules - only non-modular code.

=== Special Handling: No Explicit Modules

This example demonstrates an automatic module (modmain.auto) accessing classpath code (cpa).
Neither has a module descriptor (module-info.java).

Problem::
Maven 4's Module Source Hierarchy requires module descriptors (module-info.java) for all source entries.
This example intentionally contains only non-modular code:
+
* `cpa` - classpath code without module-info.java
* `modmain.auto` - automatic module without module-info.java
+
Since there are no explicit modules, Maven has nothing to compile.

Solution::
All compilation is done manually in `m4/compile.sh`:
+
. Manual javac invocation compiles cpa to cplib/:
+
[source,bash]
----
javac -d classes/cpa --release 11 $(find cpa -name "*.java")
jar --create --file=cplib/cpa.jar -C classes/cpa .
----
+
. Manual javac invocation compiles modmain.auto to amlib/:
+
[source,bash]
----
javac -cp cplib/* -d classes/modmain.auto --release 11 \
      $(find modmain.auto -name "*.java")
jar --create --file=amlib/modmain.auto.jar \
    -C classes/modmain.auto .
----
+
. Runtime uses automatic module on module-path and classpath:
+
[source,bash]
----
java --module-path amlib \
     -cp cplib/cpa.jar \
     -m modmain.auto/pkgmain.Main
----

This approach is necessary because:

* Maven 4's Module Source Hierarchy is designed for modular code only
* Automatic modules must be compiled as non-modular JARs (without module-info.java)
* Classpath code (unnamed module) must be compiled separately
* Automatic modules CAN access classpath code (unlike explicit modules)
* No Maven compilation is performed - pom.xml has no `<sources>` element
