:icons: font
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
== Example example_unnamed-module-reflection-illegal-access

Part of the full xref:../../README.adoc[Java 9 Jigsaw modules example] suite.

[IMPORTANT]
.Authors
====
Originally written by https://github.com/mrtnlhmnn[Martin Lehmann], https://github.com/kristines[Kristine Schaal] and https://github.com/rgrammes[RÃ¼diger Grammes] (cf. https://github.com/accso/java9-jigsaw-examples[original repository]).

Migrated for JPMS support documentation of Apache Maven^TM^ in the course of the https://open-elements.com/support-care-maven/[Maven Support & Care] program by https://github.com/ascheman[Gerd Aschemann] (and other team members) as https://github.com/support-and-care/java9-jigsaw-examples[forked repository].
Please add discussions, requirements, bugfixes, etc. to the fork instead of the original.
====

== What is this example about?

=== Modules in this example

* The unnamed module (i.e. the classpath) and "normal" modules modb and modc.
* modb is accesses from the unnamed module.
* modc is not really relevant but only needed to allow a class in modb to be exported-to only to modc.

=== Module Dependency Graph, created with https://github.com/accso/java9-jigsaw-depvis[DepVis]

image::moduledependencies.png[Example's Module Dependency Graph]

=== Example shows ...

The usage of the Java command line option `--illegal-access`, aka the "kill switch".
See https://mail.openjdk.java.net/pipermail/jigsaw-dev/2017-May/012673.html[Java9 Maillinglist] for details.

Four classes on the classpath, i.e. in the unnamed module, access other classes with reflective access.

* `cpmain/pkgcpmain.MainCallingJavaBaseJDKInternal.java` does reflective access to a class from module `java.base`, package `jdk.internal` (a package which is new in Java9).
An explicit `--add-opens` is hence needed.
* `cpmain/pkgcpmain.MainCallingJavaBaseSunNet.java`       does reflective access to a class from module `java.base`, package `sun.net` (a package which has existed before, in Java8).
The kill-switch `--illegal-access=permit` will hence work.
* `cpmain/pkgcpmain.MainCallingJavaDesktop.java`         does reflective access to a class from module `java.desktop`, package `sun.awt` (a package which has existed before, in Java8).
The kill-switch `--illegal-access=permit` will hence work.
* `cpmain/pkgcpmain.MainCallingJavaBaseModB.java`        does reflective access to a class from module `modb` (a package which has not existed before Java9).
An explicit `--add-opens` is hence needed.

*Note that the kill switch **only works for classes which had been available before Java9**, i.e. were part of Java8. See also explanation https://docs.oracle.com/javase/9/tools/java.htm#JSWOR624[here].*

See all 20 different variants of how to use the `--illegal-access=...` command line option or the `--add-opens` option in the run script `run.sh`.

=== Output

This example uses xref:../../README.adoc#golden-master-testing[golden master testing] to ensure output consistency.
The expected output is compared with actual output using `verify.sh`.

==== Expected Output

[source]
----
include::expected-result/run.txt[]
----

==== Actual Output

[source]
----
include::run-result/run.txt[]
----

==== Maven 4 Output

[source]
----
include::m4/run-result/run.txt[]
----

== Maven 4 Migration

This example required a special migration approach due to the presence of classpath code (unnamed module) that depends on explicit modules.

=== Standard Migration

The explicit modules (`modb`, `modc`) were migrated using the standard Module Source Hierarchy approach with direct paths to the original source directories.

=== Special Handling: Classpath Code Dependent on Modules

Problem::
Maven 4's Module Source Hierarchy requires module descriptors (module-info.java) for all source entries.
This example contains `cpmain`, which is classpath code (unnamed module) without module-info.java.
+
Additionally, `cpmain` needs to access classes from `modb` during compilation, requiring the modules to be compiled first.

Solution::
Hybrid compilation approach in `m4/compile.sh`:
+
. Maven compiles explicit modules (modb, modc) first
. Package modules as JARs in mlib/
. Manual javac compilation of cpmain with classpath pointing to mlib/*
+
The compilation order is critical: modules must be compiled and packaged before cpmain.
+
. Runtime uses 20 test variants with various `--illegal-access` and `--add-opens` flags to demonstrate JDK encapsulation behavior

This hybrid approach is necessary because:

* Maven 4's Module Source Hierarchy cannot compile code without module-info.java
* Classpath code (unnamed module) must be compiled separately from explicit modules
* Compilation order matters: cpmain depends on modb during compilation
* The classpath/module-path split must be maintained at both compile-time and runtime
* The example demonstrates illegal reflective access behavior with various JVM flags
