:icons: font
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
== Example example_unnamed-module_accessing-module-path

Part of the full xref:../../README.adoc[Java 9 Jigsaw modules example] suite.

[IMPORTANT]
.Authors
====
Originally written by https://github.com/mrtnlhmnn[Martin Lehmann], https://github.com/kristines[Kristine Schaal] and https://github.com/rgrammes[RÃ¼diger Grammes] (cf. https://github.com/accso/java9-jigsaw-examples[original repository]).

Migrated for JPMS support documentation of Apache Maven^TM^ in the course of the https://open-elements.com/support-care-maven/[Maven Support & Care] program by https://github.com/ascheman[Gerd Aschemann] (and other team members) as https://github.com/support-and-care/java9-jigsaw-examples[forked repository].
Please add discussions, requirements, bugfixes, etc. to the fork instead of the original.
====

== What is this example about?

=== Modules in this example

* modb, and also classes for the unnamed module (cpb, cpmain)
* cpmain contains a Main class which are started in run.sh

=== Module Dependency Graph, created with https://github.com/accso/java9-jigsaw-depvis[DepVis]

image::moduledependencies.png[Example's Module Dependency Graph]

=== Example shows ...

The examples illustrates the accessibility rules access from `Main` class in `cpmain` which are on the classpath (i.e. in the unnamed module).
It can access all classes both when ...

* ... they are in a named module in the explicit module `modb` (but only if the corresponding packages are exported!)
* ... they are in the unnamed module.

Note that is a class exists both on the classpath and in a module on the module path, the latter is taken.
Hence code in a module 'covers' code on the classpath!

The script run.sh starts both the main class `cpmain`.

=== Output

This example uses xref:../../README.adoc#golden-master-testing[golden master testing] to ensure output consistency.
The expected output is compared with actual output using `verify.sh`.

==== Expected Output

[source]
----
include::expected-result/run.txt[]
----

==== Actual Output

[source]
----
include::run-result/run.txt[]
----

==== Maven 4 Output

[source]
----
include::m4/run-result/run.txt[]
----

== Maven 4 Migration

This example required a special migration approach due to mixing modular code with classpath code (unnamed module).

=== Standard Migration

The module (modb) was migrated using the standard Module Source Hierarchy approach documented in the xref:../../README.adoc#maven-4-migration[central Maven 4 Migration guide].

=== Special Handling: Classpath Code

This example demonstrates classpath code (unnamed module) accessing modules on the module-path via `--add-modules`.

Problem::
Maven 4's Module Source Hierarchy requires module descriptors (module-info.java) for all source entries.
The `cpb` and `cpmain` packages are classpath code without module-info.java and cannot be included in the `<sources>` element.

Solution::
Hybrid compilation approach in `m4/compile.sh`:
+
. Maven compiles the module (modb) first:
+
[source,xml]
----
<sources>
  <source>
    <module>modb</module>
    <directory>src/java/modb/main</directory>
  </source>
</sources>
----
+
. Manual javac invocation compiles cpb and cpmain to cplib/:
+
[source,bash]
----
for dir in cpb cpmain; do
    javac -cp ../m4/mlib/*:../m4/classes/cpb \
          -d ../m4/classes/${dir} --release 11 \
          $(find ${dir} -name "*.java")
    jar --create --file=../m4/cplib/${dir}.jar \
        -C ../m4/classes/${dir} .
done
----
+
. Runtime uses separate paths:
+
[source,bash]
----
java --module-path mlib \
     --class-path cplib/cpmain.jar:cplib/cpb.jar \
     --add-modules modb pkgcpmain.Main
----

This hybrid approach is necessary because:

* Maven 4's Module Source Hierarchy is designed for modular code only
* Classpath code (unnamed module) must be compiled separately and placed on the classpath
* The `--add-modules modb` flag makes the module available to classpath code
* Compilation order matters: cpb must be compiled before cpmain (cpmain depends on cpb)
* Separating cplib/ from mlib/ maintains the classpath/module-path distinction
